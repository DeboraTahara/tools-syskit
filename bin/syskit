#! /usr/bin/env ruby

# Reset the interrupt handler to the default. An ignored handler is inherited,
# so this makes sure that the Roby app is based on the handler's expected state
trap('INT', 'DEFAULT')

require 'rock/bundle'

# The logs are public by default in bundles, but are private by default in Roby
# (the Roby-oriented scripts must set it to true when needed)
#
# Reset to the Roby default
Roby.app.public_logs = false

require 'syskit/cli/main'

if ARGV.first
    command_name = ARGV.first.tr('-', '_')
    if Syskit::CLI::Main.all_commands.has_key?(command_name)
        begin
            Syskit::CLI::Main.start(ARGV)
            exit 0
        rescue Roby::CLI::CLIException => e
            STDERR.puts Roby.color(e.message, :red)
            exit 1
        end
    end
end

ORIGINAL_ARGV = ARGV.dup
mode = ARGV.shift

SYSKIT_MODES = ['doc', 'ide', 'process_server']
ROBY_MODES = ['init', 'run', 'shell', 'test', 'gen', 'quit', 'restart']
if not mode || mode == "--help" || mode == "-h"
    puts "usage: syskit [#{SYSKIT_MODES.join("|")}|#{ROBY_MODES.join("|")}] <mode-arguments>"
    puts "Run 'syskit <mode> --help' for more information"
else
    if SYSKIT_MODES.include?(mode)
        require "syskit/scripts/#{mode}"
    elsif ROBY_MODES.include?(mode)
        require "roby/app/scripts/#{mode}"
    end
    
    begin
        require "syskit/scripts/#{mode}"
    rescue LoadError => e
        begin
            require "roby/app/scripts/#{mode}"
        rescue LoadError
            STDERR.puts "unknown mode '#{mode}'"
            exit(1)
        end
    end
end
